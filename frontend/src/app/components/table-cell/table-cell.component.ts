import { Component, Input, Output, EventEmitter, OnInit, OnChanges, OnDestroy, SimpleChanges, ViewChild, ElementRef, HostListener, Injector } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { ModernInputComponent } from '../modern-input/modern-input.component';
import { TableEditService } from '../../services/table-edit.service';

@Component({
  selector: 'app-table-cell',
  standalone: true,
  imports: [
    CommonModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatCheckboxModule,
    MatChipsModule,
    ModernInputComponent
  ],
  template: `
    <div class="cell-content" 
         [class.editing]="isEditing"
         (click)="onCellClick()">
      
      <!-- Display Mode (only for non-temporary rows or autogenerated fields) -->
      <span *ngIf="!effectiveIsEditing" 
            [class.primary-key]="column.isPrimaryKey"
            [class.editable]="!column.isAutoIncrement"
            [class.autogenerated]="isAutogeneratedField">
        {{ isAutogeneratedField ? 'autogenerated' : displayValue }}
      </span>
      
      <!-- Editing Mode (always visible for temporary rows with editable fields) -->
      <div *ngIf="effectiveIsEditing" class="editing-container" [class.always-editing]="shouldAlwaysEdit">
        <!-- Text Input -->
        <app-modern-input *ngIf="!isSelectField"
                          [config]="inputConfig"
                          [value]="shouldAlwaysEdit ? (value || '') : editingValue"
                          (valueChange)="onValueChange($event)"
                          (enter)="onSave()"
                          (escape)="onCancel()"
                          (tab)="onTab()"
                          (blur)="onBlur($event)"
                          class="cell-input"
                          [class.always-editing-input]="shouldAlwaysEdit"
                          #inputComponent>
        </app-modern-input>
        
        <!-- Select Dropdown -->
        <mat-form-field *ngIf="isSelectField" appearance="outline" class="cell-select">
          <mat-select [value]="editingValue" 
                      (selectionChange)="onValueChange($event.value)"
                      (closed)="isTemporaryRow ? null : onSave()">
            <mat-option *ngFor="let option of selectOptions" [value]="option.value">
              {{ option.label }}
            </mat-option>
          </mat-select>
        </mat-form-field>
        
        <!-- Checkbox -->
        <mat-checkbox *ngIf="isCheckboxField"
                      [checked]="editingValue === 'true'"
                      (change)="onValueChange($event.checked.toString())"
                      (blur)="isTemporaryRow ? null : onSave()">
        </mat-checkbox>
      </div>
    </div>
  `,
  styles: [`
    .cell-content {
      padding: 10px 12px;
      min-height: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      cursor: pointer;
      border-radius: 4px;
      transition: all 150ms ease-out;
      position: relative;
      width: 100%;
      max-width: 100%;
      min-width: 0;
      box-sizing: border-box;
      overflow: hidden;
    }

    /* Ensure the cell content maintains exact size when editing */
    .cell-content.editing {
      padding: 0; /* Remove padding so input fills cell */
    }

    :host-context(tr.temporary-row) .cell-content {
      padding: 0 !important;
      min-height: 28px;
      width: fit-content;
      max-width: 100%;
    }

    :host-context(tr.temporary-row) .cell-content.editing {
      padding: 0 !important;
      width: fit-content;
      max-width: 100%;
    }

    .cell-content:hover:not(.editing) {
      background-color: rgba(0, 0, 0, 0.02);
    }

    .cell-content.editing {
      background-color: transparent;
      cursor: default;
      border: none; /* Remove border from cell-content */
      box-shadow: none; /* Remove shadow from cell-content */
      width: 100%;
      max-width: 100%;
      min-width: 0;
      overflow: visible; /* Allow border to show */
      height: 40px;
      min-height: 40px;
      padding: 0; /* Remove padding - input will handle its own padding */
      margin: 0;
      display: flex;
      align-items: center;
    }

    /* Always editing mode for temporary rows - no special background */
    .editing-container.always-editing {
      background-color: transparent;
    }

    :host-context(tr.temporary-row) .cell-content.editing {
      background-color: transparent;
      box-shadow: none;
    }

    /* Inputs in always-editing mode should look like regular inputs */
    .always-editing-input ::ng-deep .mat-mdc-form-field-outline {
      border-color: var(--theme-outline);
    }

    .always-editing-input ::ng-deep .mat-mdc-form-field.mat-focused .mat-mdc-form-field-outline-thick {
      border-color: var(--theme-primary);
    }

    .cell-content.editable {
      position: relative;
    }

    .cell-content.editable::after {
      content: '';
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s ease;
      width: 16px;
      height: 16px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M11 4H4a2 2 2 0 0 0-2 2v14a2 2 2 0 0 0 2 2h14a2 2 2 0 0 0 2-2v-7'%3E%3C/path%3E%3Cpath d='M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z'%3E%3C/path%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    .cell-content.editable:hover::after {
      opacity: 0.5;
    }

    .cell-content .primary-key {
      font-weight: 600;
      color: var(--theme-primary);
    }

    .cell-content .editable {
      color: var(--theme-text-primary);
    }

    .cell-content .autogenerated {
      color: var(--theme-text-secondary);
      font-style: italic;
      font-size: 12px;
      opacity: 0.7;
    }

    .editing-container {
      width: 100%;
      display: flex;
      align-items: center;
      min-width: 0; /* Prevent flex from expanding */
      height: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Make the input BE the blue rectangle, not nested inside it */
    .cell-input {
      width: 100%;
      max-width: 100%;
      min-width: 0;
      height: 100%;
      display: flex;
      align-items: center;
    }

    .cell-input ::ng-deep .modern-input-container {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      height: 100% !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    .cell-input ::ng-deep .mat-mdc-form-field {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      height: 100% !important;
      margin: 0 !important;
      padding: 0 !important;
      display: block !important;
    }

    .cell-input ::ng-deep .mat-mdc-form-field-wrapper {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      height: 100% !important;
      padding: 0 !important;
      padding-bottom: 0 !important;
      margin: 0 !important;
      box-sizing: border-box !important;
    }

    .cell-input ::ng-deep .mat-mdc-text-field-wrapper {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      height: 100% !important;
      padding: 0 !important;
      margin: 0 !important;
      box-sizing: border-box !important;
      display: flex !important;
      align-items: center !important;
    }

    /* Apply blue border directly to the form field outline */
    .cell-input ::ng-deep .mat-mdc-form-field-outline {
      border: 2px solid var(--theme-primary) !important;
      border-radius: 6px !important;
      box-shadow: 0 0 0 1px var(--theme-primary) !important;
      top: 0 !important;
      bottom: 0 !important;
      height: 100% !important;
    }

    .cell-input ::ng-deep .mat-mdc-form-field-outline-thick {
      border: 2px solid var(--theme-primary) !important;
      border-radius: 6px !important;
      box-shadow: 0 0 0 1px var(--theme-primary) !important;
      top: 0 !important;
      bottom: 0 !important;
      height: 100% !important;
    }

    .cell-input ::ng-deep .mdc-notched-outline__leading,
    .cell-input ::ng-deep .mdc-notched-outline__notch,
    .cell-input ::ng-deep .mdc-notched-outline__trailing {
      height: 100% !important;
      top: 0 !important;
    }

    .cell-input ::ng-deep .mat-mdc-form-field-infix {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      padding: 0 12px !important; /* Add padding here for text spacing */
      border-top: 0 !important;
      display: flex !important;
      align-items: center !important;
      justify-content: flex-start !important;
      height: 100% !important;
      min-height: 0 !important;
      box-sizing: border-box !important;
      line-height: 1 !important;
    }

    .cell-input ::ng-deep .mdc-notched-outline {
      margin: 0 !important;
      padding: 0 !important;
    }

    .cell-input ::ng-deep .mdc-notched-outline__leading,
    .cell-input ::ng-deep .mdc-notched-outline__notch,
    .cell-input ::ng-deep .mdc-notched-outline__trailing {
      margin: 0 !important;
    }

    .cell-input ::ng-deep input {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      box-sizing: border-box !important;
      height: 100% !important;
      line-height: 40px !important; /* Match cell height for vertical centering */
      padding: 0 !important;
      margin: 0 !important;
      border: none !important;
      background: transparent !important;
      font-size: 14px !important; /* Match text size */
      vertical-align: middle !important;
    }

    .cell-input ::ng-deep .mat-mdc-form-field-subscript-wrapper {
      display: none !important;
      height: 0 !important;
      min-height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    .cell-input ::ng-deep .mat-mdc-form-field-hint-wrapper {
      display: none !important;
      height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    /* Limit input width in temporary rows to match column width */
    :host-context(tr.temporary-row) .editing-container {
      width: fit-content;
      max-width: 100%;
      display: inline-flex;
    }

    :host-context(tr.temporary-row) .cell-input {
      width: fit-content;
      max-width: 100%;
      min-width: 80px;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .modern-input-container {
      width: fit-content !important;
      max-width: 100%;
      min-width: 80px;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field {
      width: fit-content !important;
      max-width: 100%;
      min-width: 80px;
    }

    /* Compact form field for temporary rows */
    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-wrapper {
      padding-bottom: 0 !important;
      margin-bottom: 0 !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-text-field-wrapper {
      padding-bottom: 0 !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-subscript-wrapper {
      display: none !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep input {
      padding: 4px 8px !important;
      font-size: 13px !important;
      height: 28px !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-text-field-wrapper {
      width: fit-content !important;
      max-width: 100%;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field {
      margin: 0 !important;
      padding-bottom: 0 !important;
      height: 28px !important;
      line-height: 28px !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-wrapper {
      padding-bottom: 0 !important;
      height: 28px !important;
      min-height: 28px !important;
      max-height: 28px !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-text-field-wrapper {
      height: 28px !important;
      min-height: 28px !important;
      max-height: 28px !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-infix {
      width: auto !important;
      min-width: 80px;
      max-width: 200px;
      padding: 2px 6px !important;
      min-height: 20px !important;
      height: 20px !important;
      max-height: 20px !important;
      border-top: 0 !important;
      display: flex !important;
      align-items: center !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep input {
      width: auto !important;
      max-width: 200px;
      min-width: 80px;
      height: 20px !important;
      line-height: 20px !important;
      font-size: 14px !important;
      padding: 0 !important;
      margin: 0 !important;
      border: none !important;
      background: transparent !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-subscript-wrapper {
      display: none !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-outline {
      height: 28px !important;
      top: 0 !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-outline-start,
    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-outline-gap,
    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-outline-end {
      border-width: 1px !important;
      height: 28px !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-outline-thick {
      height: 28px !important;
    }

    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-outline-thick .mat-mdc-form-field-outline-start,
    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-outline-thick .mat-mdc-form-field-outline-gap,
    :host-context(tr.temporary-row) .cell-input ::ng-deep .mat-mdc-form-field-outline-thick .mat-mdc-form-field-outline-end {
      height: 28px !important;
    }

    .cell-select {
      width: 100%;
      max-width: 100%;
    }

    :host-context(tr.temporary-row) .cell-select {
      width: fit-content;
      max-width: 100%;
      min-width: 120px;
    }

    .cell-select .mat-mdc-form-field {
      width: 100%;
    }

    :host-context(tr.temporary-row) .cell-select .mat-mdc-form-field {
      width: fit-content !important;
      max-width: 100%;
      min-width: 120px;
    }

    .cell-select .mat-mdc-select {
      width: 100%;
    }
  `]
})
export class TableCellComponent implements OnInit, OnChanges, OnDestroy {
  @Input() rowIndex!: number;
  @Input() columnName!: string;
  @Input() value: any;
  @Input() column: any;
  @Input() isEditing = false;
  @Input() editingValue = '';
  @Input() selectOptions: { value: string; label: string }[] = [];
  @Input() isTemporaryRow = false;

  constructor(private elementRef: ElementRef) {}

  @Output() startEdit = new EventEmitter<{rowIndex: number, columnName: string, value: any}>();
  @Output() valueChange = new EventEmitter<any>();
  @Output() save = new EventEmitter<void>();
  @Output() cancel = new EventEmitter<void>();
  @Output() tabNext = new EventEmitter<{rowIndex: number, columnName: string}>();

  @ViewChild('inputComponent', { static: false }) inputComponent?: ModernInputComponent;
  
  inputConfig: any = {};
  private originalValue: any = null; // Track original value when editing starts
  private currentEditingValue: string = ''; // Track current value being edited
  private isHandlingBlur = false; // Flag to prevent multiple blur handlers
  private isTabNavigation = false; // Flag to indicate Tab key was pressed (prevents blur handling)

  get displayValue(): string {
    return this.formatValue(this.value);
  }

  get isSelectField(): boolean {
    return this.selectOptions.length > 0;
  }

  get isCheckboxField(): boolean {
    return this.column?.type === 'boolean';
  }

  get isAutogeneratedField(): boolean {
    return this.isTemporaryRow && (this.column?.isAutoGenerate || this.column?.isAutoIncrement || this.column?.isPrimaryKey);
  }

  get isEditableInTemporaryRow(): boolean {
    if (!this.isTemporaryRow) return true;
    // Never allow editing of primary keys, autogenerated, or autoincrement fields
    if (this.column?.isPrimaryKey || this.column?.isAutoGenerate || this.column?.isAutoIncrement) {
      return false;
    }
    return !this.isAutogeneratedField;
  }

  get shouldAlwaysEdit(): boolean {
    // Only enable always-edit mode for temporary rows with editable fields
    // Primary keys, autogenerated, and autoincrement fields should never be editable
    if (!this.isTemporaryRow) return false;
    if (this.column?.isPrimaryKey || this.column?.isAutoGenerate || this.column?.isAutoIncrement) {
      return false;
    }
    return this.isEditableInTemporaryRow;
  }

  get effectiveIsEditing(): boolean {
    // For temporary rows with editable fields, always show input
    if (this.shouldAlwaysEdit) {
      return true;
    }
    return this.isEditing;
  }

  ngOnInit() {
    this.setupInputConfig();
    // Initialize original value if we're already in editing mode
    if (this.isEditing && this.originalValue === null) {
      this.originalValue = this.value;
      this.addDocumentClickListener();
    }
  }

  ngOnDestroy() {
    // Clean up document click listener
    this.removeDocumentClickListener();
  }

  ngOnChanges(changes: SimpleChanges) {
    // Track original value when editing starts
    if (changes['isEditing'] && changes['isEditing'].currentValue && !changes['isEditing'].previousValue) {
      // Editing just started
      if (this.originalValue === null) {
        this.originalValue = this.value;
      }
      // Initialize current editing value
      this.currentEditingValue = this.editingValue || String(this.value || '');
      // Add document click listener when editing starts
      this.addDocumentClickListener();
    }
    // Clear original value when editing ends
    if (changes['isEditing'] && !changes['isEditing'].currentValue && changes['isEditing'].previousValue) {
      this.originalValue = null;
      this.currentEditingValue = '';
      this.isHandlingBlur = false;
      // Remove document click listener when editing ends
      this.removeDocumentClickListener();
    }
    // Update current editing value when editingValue changes
    if (changes['editingValue']) {
      this.currentEditingValue = this.editingValue || '';
    }
  }

  /**
   * Find the parent table row element (tr) for this cell
   */
  private getParentRowElement(): HTMLElement | null {
    let element: HTMLElement | null = this.elementRef.nativeElement;
    while (element && element.tagName !== 'TR') {
      element = element.parentElement;
    }
    return element;
  }

  /**
   * Check if a target element is within the same row as this cell
   */
  private isTargetInSameRow(target: HTMLElement): boolean {
    const rowElement = this.getParentRowElement();
    if (!rowElement) return false;
    return rowElement.contains(target);
  }

  /**
   * Check if a target element is another cell in the same row
   */
  private isTargetAnotherCellInRow(target: HTMLElement): boolean {
    const rowElement = this.getParentRowElement();
    if (!rowElement) return false;
    
    // Check if target is within the row but not within this cell
    if (rowElement.contains(target)) {
      const nativeElement = this.elementRef.nativeElement;
      return !nativeElement.contains(target);
    }
    return false;
  }

  private documentClickHandler = (event: MouseEvent) => {
    // Only handle if we're editing this cell (not temporary rows)
    if (!this.isEditing || this.shouldAlwaysEdit || this.isHandlingBlur || this.isTabNavigation) {
      return;
    }

    // Check if click is outside this cell
    const target = event.target as HTMLElement;
    const nativeElement = this.elementRef.nativeElement;
    
    // Check if the click target is inside this cell's DOM element
    if (nativeElement && !nativeElement.contains(target)) {
      // Check if target is in the same row (another cell)
      if (this.isTargetAnotherCellInRow(target)) {
        // Click is on another cell in the same row - cancel editing completely
        setTimeout(() => {
          if (this.isEditing && !this.isHandlingBlur) {
            this.isHandlingBlur = true;
            this.onCancel(); // Cancel editing when clicking another cell in same row
          }
        }, 100);
      } else if (!this.isTargetInSameRow(target)) {
        // Click is outside the row - handle blur (save or cancel based on value)
        setTimeout(() => {
          if (this.isEditing && !this.isHandlingBlur) {
            this.isHandlingBlur = true;
            this.handleBlurLogic();
          }
        }, 100);
      }
    }
  };

  private addDocumentClickListener(): void {
    // Add click listener to document to detect clicks outside
    document.addEventListener('click', this.documentClickHandler, true);
  }

  private removeDocumentClickListener(): void {
    // Remove click listener when editing ends
    document.removeEventListener('click', this.documentClickHandler, true);
  }

  private handleBlurLogic(): void {
    // Get the current value - prefer from inputComponent, then currentEditingValue, then editingValue
    let currentValue = '';
    if (this.inputComponent) {
      currentValue = this.inputComponent.internalValue() || '';
    }
    if (!currentValue) {
      currentValue = this.currentEditingValue || this.editingValue || '';
    }
    
    const originalValueStr = this.formatValue(this.originalValue);

    // Compare values (normalize for comparison)
    const valuesEqual = this.areValuesEqual(currentValue, originalValueStr);

    if (valuesEqual) {
      // No change, cancel edit (revert to original)
      this.onCancel();
    } else {
      // Value changed, save it
      // Ensure editingValue is updated before saving
      if (currentValue !== this.editingValue) {
        this.valueChange.emit(currentValue);
      }
      this.onSave();
    }
    
    this.isHandlingBlur = false;
  }

  private setupInputConfig() {
    this.inputConfig = {
      size: 'small',
      variant: 'outline',
      placeholder: `Enter ${this.column?.name || 'value'}`,
      maxLength: this.getMaxLength(),
      required: !this.column?.isNullable
    };

    if (this.column?.type === 'INTEGER' || this.column?.type === 'BIGINT') {
      this.inputConfig.type = 'number';
    } else if (this.column?.type === 'DECIMAL' || this.column?.type === 'NUMERIC') {
      this.inputConfig.type = 'number';
      this.inputConfig.step = '0.01';
    } else if (this.column?.type === 'DATE') {
      this.inputConfig.type = 'date';
    } else if (this.column?.type === 'TIMESTAMP' || this.column?.type === 'TIMESTAMPTZ') {
      this.inputConfig.type = 'datetime-local';
    }
  }

  private getMaxLength(): number {
    if (this.column?.type?.includes('VARCHAR')) {
      const match = this.column.type.match(/VARCHAR\((\d+)\)/);
      return match ? parseInt(match[1], 10) : 255;
    }
    return 255;
  }

  private formatValue(value: any): string {
    if (value === null || value === undefined) {
      return '';
    }

    if (this.column?.type === 'boolean') {
      return value ? 'Yes' : 'No';
    }

    if (this.column?.type === 'date' || this.column?.type === 'datetime') {
      return value instanceof Date ? value.toLocaleDateString() : value;
    }

    return String(value);
  }

  onCellClick() {
    // Never allow clicking to edit primary keys, autogenerated, or autoincrement fields
    if (this.column?.isPrimaryKey || this.column?.isAutoGenerate || this.column?.isAutoIncrement) {
      return;
    }
    
    if (!this.isEditing && this.isEditableInTemporaryRow) {
      // Store original value when starting to edit
      this.originalValue = this.value;
      this.startEdit.emit({
        rowIndex: this.rowIndex,
        columnName: this.columnName,
        value: this.value
      });
    }
  }

  onValueChange(value: any) {
    // Track current editing value
    this.currentEditingValue = String(value || '');
    
    // For always-editing mode, update the value directly in the record
    if (this.shouldAlwaysEdit) {
      // Update the value in the record immediately
      const columnName = this.columnName.replace('reg_', '');
      if (this.column) {
        // Emit value change with column information for always-editing mode
        this.valueChange.emit({ value, columnName: this.columnName, rowIndex: this.rowIndex });
      }
    } else {
      this.valueChange.emit(value);
    }
  }

  onSave() {
    // For temporary rows (always-editing mode), update value in record but don't emit save
    // Save should only happen via explicit "Save" button click
    if (this.shouldAlwaysEdit || this.isTemporaryRow) {
      // Get the current value from the input if available, otherwise use value prop
      let currentValue = this.value || '';
      if (this.inputComponent) {
        currentValue = this.inputComponent.internalValue() || currentValue;
      } else {
        const inputElement = document.querySelector(
          `tr[mat-row].temporary-row td[mat-cell] app-table-cell[ng-reflect-column-name="${this.columnName}"] input`
        ) as HTMLInputElement;
        if (inputElement) {
          currentValue = inputElement.value || currentValue;
        }
      }
      
      // Emit value change to ensure the value is saved to the record
      this.valueChange.emit({ value: currentValue, columnName: this.columnName, rowIndex: this.rowIndex });
      // Don't emit save for temporary rows - only Save button should trigger save
      return;
    }
    
    // For existing records, emit save event
    this.save.emit();
  }

  onCancel() {
    this.originalValue = null;
    this.currentEditingValue = '';
    this.cancel.emit();
  }

  onBlur(event?: any) {
    // Skip blur handling for temporary rows (always-editing mode)
    // Temporary rows should only save via explicit "Save" button
    if (this.shouldAlwaysEdit || this.isTemporaryRow) {
      return; // Skip blur handling for temporary rows
    }

    // Skip blur if Tab navigation is in progress
    if (this.isTabNavigation) {
      this.isTabNavigation = false; // Reset flag
      return;
    }

    if (!this.isEditing || this.isHandlingBlur) {
      return; // Not currently editing or already handling
    }

    // Get the related target (element receiving focus)
    const relatedTarget = event?.relatedTarget as HTMLElement;
    
    // Check if blur is to another cell in the same row
    if (relatedTarget && this.isTargetAnotherCellInRow(relatedTarget)) {
      // Blur to another cell in same row - cancel editing completely
      setTimeout(() => {
        if (this.isEditing && !this.isHandlingBlur) {
          this.isHandlingBlur = true;
          this.onCancel(); // Cancel editing when moving to another cell in same row
        }
      }, 100);
      return;
    }

    // Check if blur is to an element outside the row
    if (relatedTarget && !this.isTargetInSameRow(relatedTarget)) {
      // Blur is outside the row - handle blur (save or cancel based on value)
      setTimeout(() => {
        if (this.isEditing && !this.isHandlingBlur) {
          this.isHandlingBlur = true;
          this.handleBlurLogic();
        }
      }, 200); // Small delay to ensure valueChange has been processed
      return;
    }

    // If no related target or unclear, use document click handler logic
    // This will be handled by documentClickHandler
  }

  private areValuesEqual(val1: any, val2: any): boolean {
    // Normalize values for comparison
    const normalize = (v: any) => {
      if (v === null || v === undefined) return '';
      return String(v).trim();
    };

    return normalize(val1) === normalize(val2);
  }

  onTab() {
    // Set flag to prevent blur handling
    this.isTabNavigation = true;
    
    // For temporary rows, just move to next field without saving
    if (this.isTemporaryRow || this.shouldAlwaysEdit) {
      // Update value in record but don't save
      if (this.inputComponent) {
        const currentValue = this.inputComponent.internalValue() || '';
        this.onValueChange(currentValue);
      }
      // Move to next field
      this.tabNext.emit({
        rowIndex: this.rowIndex,
        columnName: this.columnName
      });
      return;
    }
    
    // For existing records, save current edit and move to next field
    this.save.emit();
    this.tabNext.emit({
      rowIndex: this.rowIndex,
      columnName: this.columnName
    });
  }
}



