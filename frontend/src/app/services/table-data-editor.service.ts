import { Injectable, inject } from '@angular/core';
import { Table, TableColumn } from '../models/table.model';
import { TableEditService } from './table-edit.service';
import { TableDataService, DataChangeEvent } from './table-data.service';

/**
 * Service to handle inline data editing in table views
 * Manages saving edits, validating required fields, and temporary record management
 */
@Injectable({
  providedIn: 'root'
})
export class TableDataEditorService {
  private tableEditService = inject(TableEditService);
  private tableDataService = inject(TableDataService);

  /**
   * Save an edit to a table cell
   * Handles both regular records and temporary records
   */
  saveEdit(
    rowIndex: number,
    columnName: string,
    element: any,
    table: Table,
    originalData: any[],
    onDataChanged: (event: DataChangeEvent) => void
  ): { convertedToPermanent: boolean } {
    const newValue = this.tableEditService.editingValue();
    const column = table.columns.find(col => col.name === columnName.replace('reg_', ''));
    
    if (!column) {
      return { convertedToPermanent: false };
    }
    
    const parsedValue = this.tableEditService.parseValue(String(newValue || ''), column.name, table);
    element[column.name] = parsedValue;
    
    // If this is a temporary record, check if all required fields are filled
    if (element._isTemporary) {
      if (this.validateRequiredFields(element, table)) {
        // All required fields are filled, convert to permanent record
        delete element._isTemporary;
        // Add to originalData
        originalData.push(element);
        onDataChanged(this.tableDataService.prepareCreateEvent(table, element));
        // Return a flag indicating the record was converted to permanent
        return { convertedToPermanent: true };
      } else {
        // Still missing required fields, just update the value
        onDataChanged(this.tableDataService.prepareUpdateEvent(table, element, columnName, parsedValue));
      }
    } else {
      // Regular record update
      onDataChanged(this.tableDataService.prepareUpdateEvent(table, element, columnName, parsedValue));
    }
    
    this.tableEditService.cancelEdit();
    return { convertedToPermanent: false };
  }

  /**
   * Validate that all required fields in a record are filled
   * Returns boolean and optionally detailed information about missing fields
   */
  validateRequiredFields(record: any, table: Table, returnDetails: boolean = false): boolean | { isValid: boolean; missingFields: string[] } {
    if (!table) return returnDetails ? { isValid: true, missingFields: [] } : true;
    const requiredColumns = table.columns.filter(col => 
      !col.isNullable && !col.isAutoIncrement && !col.isAutoGenerate
    );
    
    const missingFields: string[] = [];
    const isValid = requiredColumns.every(col => {
      const value = record[col.name];
      const isFilled = value !== null && value !== undefined && value !== '';
      if (!isFilled) {
        missingFields.push(col.name);
      }
      return isFilled;
    });
    
    if (returnDetails) {
      return { isValid, missingFields };
    }
    return isValid;
  }

  /**
   * Validate that all required fields before a given column are filled
   * Used to prevent Tab navigation if previous required fields are incomplete
   */
  validatePreviousRequiredFields(record: any, table: Table, currentColumnName: string): { isValid: boolean; missingFields: string[] } {
    if (!table) return { isValid: true, missingFields: [] };
    
    const currentColumnIndex = table.columns.findIndex(col => col.name === currentColumnName);
    if (currentColumnIndex === -1) return { isValid: true, missingFields: [] };
    
    // Get all required columns before the current one
    const previousRequiredColumns = table.columns
      .slice(0, currentColumnIndex)
      .filter(col => !col.isNullable && !col.isAutoIncrement && !col.isAutoGenerate);
    
    const missingFields: string[] = [];
    const isValid = previousRequiredColumns.every(col => {
      const value = record[col.name];
      const isFilled = value !== null && value !== undefined && value !== '';
      if (!isFilled) {
        missingFields.push(col.name);
      }
      return isFilled;
    });
    
    return { isValid, missingFields };
  }

  /**
   * Get the next editable column after a given column
   * Never returns primary keys, autogenerated, or autoincrement columns
   */
  getNextEditableColumn(table: Table, currentColumnName: string): TableColumn | null {
    if (!table) return null;
    
    const currentColumnIndex = table.columns.findIndex(col => col.name === currentColumnName);
    if (currentColumnIndex === -1) return null;
    
    // Find next editable column (skip primary keys, autogenerated, and autoincrement fields)
    for (let i = currentColumnIndex + 1; i < table.columns.length; i++) {
      const column = table.columns[i];
      // Never allow editing of primary keys, autogenerated, or autoincrement fields
      if (!column.isPrimaryKey && !column.isAutoGenerate && !column.isAutoIncrement) {
        return column;
      }
    }
    
    return null;
  }

  /**
   * Remove a temporary record from the data array
   */
  removeTemporaryRecord(
    temporaryRecord: any,
    temporaryRecordIndex: number | null,
    filteredData: any[],
    onPaginationUpdate: () => void
  ): { temporaryRecord: any | null; temporaryRecordIndex: number | null } {
    if (temporaryRecord && temporaryRecordIndex !== null) {
      // Remove from filteredData
      const index = filteredData.indexOf(temporaryRecord);
      if (index !== -1) {
        filteredData.splice(index, 1);
      }
      
      // Update pagination
      onPaginationUpdate();
      
      return { temporaryRecord: null, temporaryRecordIndex: null };
    }
    return { temporaryRecord, temporaryRecordIndex };
  }

  /**
   * Start adding a new record (creates temporary record)
   * NEW APPROACH: Just creates and returns the record object
   * Component handles adding to temporaryRecords array
   */
  startAddRecord(
    table: Table,
    originalData: any[]
  ): any {
    // Create a temporary record
    const newRecord = this.tableDataService.createRecord(table, originalData);
    newRecord._isTemporary = true; // Mark as temporary
    
    return newRecord;
  }
}

